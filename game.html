<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <link rel="stylesheet" href="style.css"> -->
    <style>
        canvas {
            border: 1px solid #d3d3d3;
            background-color: #211951
        }
    </style>
    <title>Playing</title>
</head>

<body>
</body>

<script>


    //Animation.js

    (() => {
        let body = document.querySelector("body");
        console.log("Running IFFE.");
        let noteTimes;
        let noteBeginnings = [];
        // let songTitle = "Bonetrousle";
        // let songTitle = "Ghost_Fight";
        let songTitle = "Spooktune";
        let song = new Audio(songTitle + ".mp3");
        async function getFile() {
            let file = await fetch(songTitle + "_map.txt");
            let txt = await file.text();
            noteTimes = txt.split(/[\r\t\n]/);
            noteTimes = noteTimes.filter(function (e) { return e != "" });
            for (let index = 0; index < noteTimes.length; index++) {
                noteTimes[index] = Math.round(noteTimes[index] * 100) / 100;
            }
            console.log(noteTimes);
            for (let index = 0; index < noteTimes.length / 2; index = index + 2) {
                noteBeginnings.push(noteTimes[index]);
            }
        };
        getFile();
        song.volume = 0.3;
        // song.play();
        let clock = document.createElement("span");

        clock.classList.add('clock');
        body.appendChild(clock);
        let playing = false;

        function startTimer() {

            if (!playing) {
                let noteNumber = 0;
                function countUp() {
                    if (noteNumber < noteTimes.length) {
                        if (noteTimes[noteNumber] == (Math.round(((song.currentTime * 100))) / 100) || noteTimes[noteNumber] == ((Math.round(((song.currentTime * 100))) / 100) + 0.01) || noteTimes[noteNumber] == ((Math.round(((song.currentTime * 100))) / 100) - 0.01)) {
                            console.log("Hit note: " + (Math.round(song.currentTime * 100) / 100) + "/" + noteTimes[noteNumber]);
                            noteNumber = noteNumber + 2;
                        }
                    }
                    console.log(noteNumber);
                }
                song.play();
                let timer = setInterval(countUp, 1);
                playing = true;
            }
        }
        // let gameWindow = document.createElement("canvas");
        // gameWindow.classList.add("game");
        // gameWindow.style.margin = 0;
        // gameWindow.setAttribute("height", "1080");
        // gameWindow.setAttribute("width", "1920");
        // gameWindow.style.background = "blanchedalmond";
        // let ctx = gameWindow.getContext("2d");
        // body.appendChild(gameWindow);

        window.onload = () => {

        }
        //IFFE

        //End of Animation.js
        started = false;
        function startGame() {
            let state;
            if (!started) {
                started = true;
                //game timer, used to sync upeveryting
                timer = 0.0;
                setInterval(() => {
                    timer += 0.01;
                }, 10)

                //spawn time for every note, need to be synced
                // notes = [0.494354, 0.716916, 1.047800, 1.461406, 1.847438, 2.261043, 
                // 2.674649, 3.060680, 3.446712, 3.860317, 4.246349, 4.632381, 5.045986,
                //  5.459592, 5.845624, 6.259229, 6.645261, 7.031293, 7.444898, 7.637914, 
                //  7.886077, 8.299683, 8.492698, 8.658141, 9.071746, 9.292336, 9.485351, 
                //  9.678367, 9.871383, 10.064399, 10.284989, 10.671020, 10.836463, 11.057052, 
                //  11.277642, 11.470658, 11.691247, 11.884263, 12.270295, 13.262948, 13.455964, 
                //  13.676553, 13.897143, 14.255601, 14.641633, 14.834649, 15.055238, 15.468844, 
                //  15.661859, 15.882449, 16.075465, 16.268481, 16.489070, 16.682086, 17.068118, 
                //  17.261134, 17.481723, 17.674739, 17.867755, 18.088345, 18.281361, 18.667392, 
                //  19.632472, 19.853061, 20.073651, 20.294240, 20.625125, 21.066304, 21.286893, 
                //  21.479909, 21.865941, 22.058957, 22.307120, 22.500136, 22.693152, 22.886168, 
                //  23.079184, 23.465215, 23.685805, 23.878821, 24.099410, 24.292426, 24.485442, 
                //  24.678458, 25.036916, 26.057143, 26.250159, 26.470748, 26.691338, 27.049796, 
                //  27.435828, 27.628844, 27.849433, 28.235465, 28.428481, 28.676644, 28.869660, 
                //  29.090249, 29.283265, 29.476281, 29.862313, 30.055329, 30.275918, 30.496508, 
                //  30.689524, 30.882540, 31.075556, 31.461587, 32.426667, 32.647256, 32.867846, 33.088435, 33.474467, 33.860499, 34.081088, 34.301678, 34.660136, 34.880726, 35.073741, 35.294331, 35.514921, 35.707937, 36.121542, 36.286984, 36.645442, 36.838458, 37.059048, 37.445079, 37.638095, 37.858685, 38.851338, 39.071927, 39.264943, 39.485533, 39.843991, 40.230023, 40.450612, 40.671202, 41.084807, 41.277823, 41.498413, 41.691429, 41.912018, 42.132608, 42.628934, 42.766803, 43.070113, 43.263129, 43.483719, 43.676735, 43.897324, 44.090340, 44.338503, 45.248435, 45.469025, 45.662041, 45.827483, 46.268662, 46.654694, 46.875283, 47.068299, 47.454331, 47.674921, 47.867937, 48.088526, 48.309116, 48.667574, 48.888163, 49.108753, 49.467211, 49.660227, 49.880816, 50.266848, 50.487438, 50.708027, 51.645533, 51.866122, 52.059138, 52.279728, 52.665760, 53.079365, 53.272381, 53.492971, 53.851429, 54.072018, 54.292608, 54.651066, 54.844082, 55.092245, 55.312834, 55.505850, 55.836735, 56.222766, 56.443356, 56.663946, 57.022404, 57.380862]
                notes = noteBeginnings;
                //game data
                count = 0;
                spawned_notes = []
                past_notes = []
                effects = []
                target_line_y = 400


                myGameArea.start();

            }
        }
        function endGame(state) {
            clearInterval();
            console.log("end")
            myGameArea.song.pause();
            clearInterval(myGameArea.interval)
            if (state == "fail") {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = "90pt Comic Sans MS";
                ctx.fillText("You lose", canvas.width / 2, canvas.height / 2);

            }
            if (state == "win") {
                let score = ((count + 35) / (noteBeginnings.length + 35)) * 100;
                if (score < 40) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "90pt Comic Sans MS";
                    ctx.fillText("Congratulations, You earned a D rank, you have hit " + count + "/ " + noteBeginnings.length + " notes", canvas.width / 2, canvas.height / 2);
                }
                else if (score < 60) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "90pt Comic Sans MS";
                    ctx.fillText("Congratulations, You earned a C rank, you have hit " + count + "/ " + noteBeginnings.length + " notes", canvas.width / 2, canvas.height / 2);
                }
                else if (score < 80) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "90pt Comic Sans MS";
                    ctx.fillText("Congratulations, You earned a B rank, you have hit " + count + "/" + noteBeginnings.length + " notes", canvas.width / 2, canvas.height / 2);
                }
                else if (score < 100) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "90pt Comic Sans MS";
                    ctx.fillText("Congratulations, You earned a A rank, you have hit " + count + "/ " + noteBeginnings.length + " notes", canvas.width / 2, canvas.height / 2);
                }
                else {
                    clearInterval(myGameArea.interval);
                    ctx.font = "50pt Comic Sans MS";
                    ctx.fillText("Congratulations, You earned a S rank, Flawless Score", canvas.width / 2, canvas.height / 2);
                }
            }
        }
        //the actual note
        function Component(width, height, color, x, y, spawnTime, lane) {
            this.width = width;
            this.height = height;
            this.speed = 7.5;
            this.color = color
            this.x = x;
            this.y = y;
            this.hit = false;
            this.spawnTime = spawnTime;
            this.lane = lane;
            ctx = myGameArea.context;
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.width, this.height);

            this.update = function () {
                ctx = myGameArea.context;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        //the effect after each note is pressed
        function Effect(width, height, color, x, y) {
            this.width = width;
            this.height = height;
            this.color = color
            this.x = x
            this.y = y
            this.opacity = 0.3

            ctx = myGameArea.context;
            ctx.fillStyle = this.color.substring(0, this.color.length - 1) + ',' + this.opacity + ')';
            ctx.fillRect(this.x, this.y, this.width, this.height);

            this.update = function () {
                ctx = myGameArea.context;
                this.opacity -= 0.01
                this.width += 1
                this.height += 1

                ctx.fillStyle = this.color.substring(0, this.color.length - 1) + ',' + this.opacity + ')'
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        //score board 
        function Score(count) {
            this.count = count
            ctx = myGameArea.context;
            ctx.font = "20px Arial";
            text = "Your Score: " + count
            ctx.fillText(text, 5, 40);
            this.update = function (count) {
                ctx = myGameArea.context;
                ctx.font = "20px Arial";
                text = "Your Score: " + count
                ctx.fillText(text, 5, 40);
            }
        }

        //bottom text
        function Text(text, x, y) {
            ctx = myGameArea.context;
            ctx.font = "60px Arial";
            ctx.fillText(text, x, y);

            this.update = function (count) {
                ctx = myGameArea.context;
                ctx.font = "60px Arial";
                ctx.fillText(text, x, y);
            }
        }


        //game logic 
        function updateGameArea() {
            myGameArea.clear();
            if (notes.length != 0) {

                //fire a note
                if (Math.abs(timer - notes[0]) < 0.01) {
                    let n = notes.shift();
                    let lane = Math.floor(Math.random() * 4);
                    let note = new Component(30, 30, "#15F5BA", 70 + lane * 100, 10, n, lane);
                    spawned_notes.push(note);
                    startTimer();
                }

                //handle existing note on canvas
                if (spawned_notes.length != 0) {
                    spawned_notes.forEach((note) => {

                        if (!note.hit) {
                            note.y += note.speed;
                        }
                        //if pass line
                        if (note.y > myGameArea.target_line_y) {
                            note.color = "red"
                            past_notes.push(spawned_notes.shift())
                            count--;
                        }
                        note.update();
                    })

                    past_notes.forEach(note => {
                        note.y += 2;
                        note.update();
                    })

                    //the target_note (which is the lowest note above line)
                    let target_note = spawned_notes[0]


                    if (myGameArea.key) {

                        switch (myGameArea.key) {
                            //q, lane 1
                            case 113:
                                target_note.hit = target_note.lane == 0
                                break;
                            //w, lane 2
                            case 119:
                                target_note.hit = target_note.lane == 1
                                break;
                            //o, lane 3
                            case 111:
                                target_note.hit = target_note.lane == 2
                                break;
                            //p, lane 4
                            case 112:
                                target_note.hit = target_note.lane == 3
                                break;
                        }
                        myGameArea.key = false;

                        //check score (comparing distance between line and note)
                        if (target_note.hit) {
                            let _x = target_note.x
                            let _y = target_note.y;
                            let dist = Math.abs(_y - target_line_y)
                            if (dist < 20) {
                                count++
                                effects.push(new Effect(40, 40, "rgb(21, 245, 186)", _x, _y))
                            }
                            if (dist > 20 && dist < 40) {
                                effects.push(new Effect(40, 40, "rgb(255, 244, 85)", _x, _y))
                            }
                            if (dist > 40) {
                                count--
                                effects.push(new Effect(40, 40, "rgb(255, 32, 78)", _x, _y))
                            }

                            spawned_notes.shift();

                            if (count == - 35) {
                                // console.log("end")
                                // myGameArea.song.pause();
                                // clearInterval(myGameArea.interval)
                                //See "endGame()"
                                endGame("fail");

                            }
                        }

                    }

                    //remove notes out of canvas
                    if (target_note.y > 500) {
                        spawned_notes.shift();
                    }
                }

                effects.forEach((effect) => {
                    effect.update()
                })



            }

            target_line.update()
            myGameArea.score.update(count)
            myGameArea.q.update()
            myGameArea.w.update()
            myGameArea.o.update()
            myGameArea.p.update()


        }

        var myGameArea = {
            canvas: document.createElement("canvas"),
            startButton: document.createElement("button"),
            // song: new Audio("Bonetrousle.mp3"),



            init: function () {

                this.canvas.width = 500;
                this.canvas.height = 500;
                this.context = this.canvas.getContext("2d");
                document.body.append(this.canvas);
                this.target_line_y = 400;
                target_line = new Component(500, 3, "#F0F3FF", 0, this.target_line_y);
                window.addEventListener('keypress', function (e) {
                    myGameArea.key = e.keyCode;
                })

                this.startButton.innerHTML = "Start"
                this.startButton.addEventListener("click", startGame)
                document.body.append(this.startButton)
                this.score = new Score(0)
                this.q = new Text("Q", 60, 470)
                this.w = new Text("W", 150, 470)
                this.o = new Text("O", 260, 470)
                this.p = new Text("P", 360, 470)



            },
            end: function () {
                if (song.duration == song.currentTime) {
                    endGame("win");
                }
            },
            start: function () {
                this.interval = setInterval(updateGameArea, 10);
                // this.song.play()
            },
            clear: function () {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }
        myGameArea.init()
    })();
</script>

</html>